爬虫是典型的 I/O 密集型任务,通过前面的课程，我们已经知道了可以通过多线程的方式为爬虫提速. 事实上，还有一种非常适合 I/O 密集型任务的并发编程方式，称之为**异步编程**，也可以称为异步 I/O。通过多个子程序相互协作的方式来提升 CPU 的利用率.

## 阻塞
阻塞状态指程序未得到所需计算资源时被挂起的状态。程序在等待某个操作完成期间，自身无法继续处理其他的事情.最典型的就是 I/O 中断（包括网络 I/O 、磁盘 I/O 、用户输入等）、休眠操作、等待某个线程执行结束
**eg**: 文件操作：程序读取或写入文件时，需要等待数据完成传输。
死锁（Deadlocks）：两个或多个线程因相互等待对方释放资源而永远无法继续。
等待用户输入，例如从控制台读取数据。

## 非阻塞
程序在等待某操作过程中，自身不被阻塞，可以继续处理其他的事情,仅当程序封装的级别可以囊括独立的子程序单元时，它才可能存在非阻塞状态。
如果是 CPU 密集型任务，阻塞可能是由于 GIL。
如果是 I/O 密集型任务，阻塞更多与操作系统层的资源管理相关

## 同步
不同程序单元为了完成某个任务，在执行过程中需靠某种通信方式以协调一致，我们称这些程序单元是同步执行的。例如给银行账户存钱的操作，在代码中使用了“锁”作为通信信号，让多个存钱操作强制排队顺序执行，这就是所谓的同步。
## 异步
不同程序单元在执行过程中无需通信协调，也能够完成一个任务，这种方式我们就称之为异步。例如，使用爬虫下载页面时，调度程序调用下载程序后，即可调度其他任务，而无需与该下载任务保持通信以协调行为。很显然，异步操作的完成时刻和先后顺序并不能确定。
同步与异步的关注点是**消息通信机制**，最终表现出来的是“有序”和“无序”的区别；阻塞和非阻塞的关注点是**程序在等待消息时状态**


# 生成器和协程
异步编程是一种“协作式并发”, 即通过**多个子程序相互协作的方式**提升 CPU 的利用率，从而减少程序在阻塞和等待中浪费的时间，最终达到并发的效果。我们可以将多个相互协作的子程序称为“协程”，它是实现异步编程的关键。先通过下面的代码，看看什么是生成器。
def calc_average():
    total, counter = 0, 0
    avg_value = None
    while True:
        curr_value = yield avg_value
        total += curr_value
        counter += 1
        avg_value = total / counter


def main():
    obj = calc_average()
    # 生成器预激活
    obj.send(None)
    for _ in range(5):
        print(obj.send(float(input())))


if __name__ == '__main__':
    main()


# 异步函数
async，await可以简化协程代码的编写，可以用更为简单的方式让多个子程序很好的协作起来。让display函数以异步的方式运转。
import asyncio
import time


async def display(num):
    await asyncio.sleep(1)
    print(num)


def main():
    start = time.time()
    objs = [display(i) for i in range(1, 10)]
    loop = asyncio.get_event_loop()
    loop.run_until_complete(asyncio.wait(objs))
    loop.close()
    end = time.time()
    print(f'{end - start:.3f}秒')


if __name__ == '__main__':
    main()

当协程遭遇 I/O 操作阻塞时，就会到事件循环中监听 I/O 操作是否完成，并注册自身的上下文以及自身的唤醒函数（以便恢复执行），之后该协程就变为阻塞状态。
上面的第12行代码创建了9个协程对象并放到一个列表中，第13行代码通过asyncio模块的get_event_loop函数获得了系统的事件循环，第14行通过asyncio模块的run_until_complete函数将协程对象挂载到事件循环上。
执行上面的代码会发现，9个分别会阻塞1秒钟的协程总共只阻塞了约1秒种的时间，因为阻塞的协程对象会放弃对 CPU 的占有而不是让 CPU 处于闲置状态，这种方式大大的提升了 CPU 的利用率。

aiohttp库
